/* tslint:disable */
/* eslint-disable */
/**
 * Apache Fineract
 * Apache Fineract is a secure, multi-tenanted microfinance platform  The goal of the Apache Fineract API is to empower developers to build apps on top of the Apache Fineract Platform<br>The [reference app](https://cui.fineract.dev) (username: mifos, password: password) works on the same demo tenant as the interactive links in this documentation  - The API is organized around [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) - Find out more about Apache Fineract [here](/fineract-provider/api-docs/apiLive.htm#top) - You can [Try The API From Your Browser](/fineract-provider/api-docs/apiLive.htm#interact) - The Generic Options are available [here](/fineract-provider/api-docs/apiLive.htm#genopts) - Find out more about [Updating Dates and Numbers](/fineract-provider/api-docs/apiLive.htm#dates_and_numbers) - For the Authentication and the Basic of HTTP and HTTPS refer [here](/fineract-provider/api-docs/apiLive.htm#authentication_overview) - Check about ERROR codes [here](/fineract-provider/api-docs/apiLive.htm#errors)  Please refer to the [old documentation](/fineract-provider/api-docs/apiLive.htm) for any documentation queries
 *
 * The version of the OpenAPI document: 1.5.0-66-gffae7d4-dirty
 * Contact: dev@fineract.apache.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { FormDataContentDisposition } from '../models';
// @ts-ignore
import { JournalEntryCommand } from '../models';
// @ts-ignore
import { JournalEntryData } from '../models';
// @ts-ignore
import { PostJournalEntriesResponse } from '../models';
// @ts-ignore
import { PostJournalEntriesTransactionIdRequest } from '../models';
// @ts-ignore
import { PostJournalEntriesTransactionIdResponse } from '../models';
/**
 * JournalEntriesApi - axios parameter creator
 * @export
 */
export const JournalEntriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note: A Balanced (simple) Journal entry would have atleast one \"Debit\" and one \"Credit\" entry whose amounts are equal  Compound Journal entries may have \"n\" debits and \"m\" credits where both \"m\" and \"n\" are greater than 0 and the net sum or all debits and credits are equal    Mandatory Fields officeId, transactionDate   credits- glAccountId, amount, comments    debits-  glAccountId, amount, comments    Optional Fields paymentTypeId, accountNumber, checkNumber, routingCode, receiptNumber, bankNumber
         * @summary Create \"Balanced\" Journal Entries
         * @param {string} [command] command
         * @param {JournalEntryCommand} [journalEntryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGLJournalEntry: async (command?: string, journalEntryCommand?: JournalEntryCommand, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/journalentries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)

            if (command !== undefined) {
                localVarQueryParameter['command'] = command;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(journalEntryCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API calculates the running balances for office. If office ID not provided this API calculates running balances for all offices.  Mandatory Fields officeId
         * @summary Update Running balances for Journal Entries
         * @param {string} transactionId transactionId
         * @param {string} [command] command
         * @param {PostJournalEntriesTransactionIdRequest} [postJournalEntriesTransactionIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReversalJournalEntry: async (transactionId: string, command?: string, postJournalEntriesTransactionIdRequest?: PostJournalEntriesTransactionIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('createReversalJournalEntry', 'transactionId', transactionId)
            const localVarPath = `/journalentries/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)

            if (command !== undefined) {
                localVarQueryParameter['command'] = command;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postJournalEntriesTransactionIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [officeId] 
         * @param {string} [dateFormat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJournalEntriesTemplate: async (officeId?: number, dateFormat?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/journalentries/downloadtemplate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)

            if (officeId !== undefined) {
                localVarQueryParameter['officeId'] = officeId;
            }

            if (dateFormat !== undefined) {
                localVarQueryParameter['dateFormat'] = dateFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FormDataContentDisposition} [file] 
         * @param {string} [locale] 
         * @param {string} [dateFormat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJournalEntriesTemplate: async (file?: FormDataContentDisposition, locale?: string, dateFormat?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/journalentries/uploadtemplate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', new Blob([JSON.stringify(file)], { type: "application/json", }));
            }
    
            if (locale !== undefined) { 
                localVarFormParams.append('locale', locale as any);
            }
    
            if (dateFormat !== undefined) { 
                localVarFormParams.append('dateFormat', dateFormat as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Example Requests:  journalentries/1    journalentries/1?fields=officeName,glAccountId,entryType,amount  journalentries/1?runningBalance=true  journalentries/1?transactionDetails=true
         * @summary Retrieve a single Entry
         * @param {number} journalEntryId journalEntryId
         * @param {boolean} [runningBalance] runningBalance
         * @param {boolean} [transactionDetails] transactionDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retreiveJournalEntryById: async (journalEntryId: number, runningBalance?: boolean, transactionDetails?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'journalEntryId' is not null or undefined
            assertParamExists('retreiveJournalEntryById', 'journalEntryId', journalEntryId)
            const localVarPath = `/journalentries/{journalEntryId}`
                .replace(`{${"journalEntryId"}}`, encodeURIComponent(String(journalEntryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)

            if (runningBalance !== undefined) {
                localVarQueryParameter['runningBalance'] = runningBalance;
            }

            if (transactionDetails !== undefined) {
                localVarQueryParameter['transactionDetails'] = transactionDetails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The list capability of journal entries can support pagination and sorting.  Example Requests:  journalentries  journalentries?transactionId=PB37X8Y21EQUY4S  journalentries?officeId=1&manualEntriesOnly=true&fromDate=1 July 2013&toDate=15 July 2013&dateFormat=dd MMMM yyyy&locale=en  journalentries?fields=officeName,glAccountName,transactionDate  journalentries?offset=10&limit=50  journalentries?orderBy=transactionId&sortOrder=DESC  journalentries?runningBalance=true  journalentries?transactionDetails=true  journalentries?loanId=12  journalentries?savingsId=24
         * @summary List Journal Entries
         * @param {number} [officeId] officeId
         * @param {number} [glAccountId] glAccountId
         * @param {boolean} [manualEntriesOnly] manualEntriesOnly
         * @param {object} [fromDate] fromDate
         * @param {object} [toDate] toDate
         * @param {string} [transactionId] transactionId
         * @param {number} [entityType] entityType
         * @param {number} [offset] offset
         * @param {number} [limit] limit
         * @param {string} [orderBy] orderBy
         * @param {string} [sortOrder] sortOrder
         * @param {string} [locale] locale
         * @param {string} [dateFormat] dateFormat
         * @param {number} [loanId] loanId
         * @param {number} [savingsId] savingsId
         * @param {boolean} [runningBalance] runningBalance
         * @param {boolean} [transactionDetails] transactionDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAll1: async (officeId?: number, glAccountId?: number, manualEntriesOnly?: boolean, fromDate?: object, toDate?: object, transactionId?: string, entityType?: number, offset?: number, limit?: number, orderBy?: string, sortOrder?: string, locale?: string, dateFormat?: string, loanId?: number, savingsId?: number, runningBalance?: boolean, transactionDetails?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/journalentries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)

            if (officeId !== undefined) {
                localVarQueryParameter['officeId'] = officeId;
            }

            if (glAccountId !== undefined) {
                localVarQueryParameter['glAccountId'] = glAccountId;
            }

            if (manualEntriesOnly !== undefined) {
                localVarQueryParameter['manualEntriesOnly'] = manualEntriesOnly;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }

            if (dateFormat !== undefined) {
                localVarQueryParameter['dateFormat'] = dateFormat;
            }

            if (loanId !== undefined) {
                localVarQueryParameter['loanId'] = loanId;
            }

            if (savingsId !== undefined) {
                localVarQueryParameter['savingsId'] = savingsId;
            }

            if (runningBalance !== undefined) {
                localVarQueryParameter['runningBalance'] = runningBalance;
            }

            if (transactionDetails !== undefined) {
                localVarQueryParameter['transactionDetails'] = transactionDetails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {number} [entryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveJournalEntries: async (offset?: number, limit?: number, entryId?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/journalentries/provisioning`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (entryId !== undefined) {
                localVarQueryParameter['entryId'] = entryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [officeId] 
         * @param {string} [currencyCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOpeningBalance: async (officeId?: number, currencyCode?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/journalentries/openingbalance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)

            if (officeId !== undefined) {
                localVarQueryParameter['officeId'] = officeId;
            }

            if (currencyCode !== undefined) {
                localVarQueryParameter['currencyCode'] = currencyCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JournalEntriesApi - functional programming interface
 * @export
 */
export const JournalEntriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JournalEntriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Note: A Balanced (simple) Journal entry would have atleast one \"Debit\" and one \"Credit\" entry whose amounts are equal  Compound Journal entries may have \"n\" debits and \"m\" credits where both \"m\" and \"n\" are greater than 0 and the net sum or all debits and credits are equal    Mandatory Fields officeId, transactionDate   credits- glAccountId, amount, comments    debits-  glAccountId, amount, comments    Optional Fields paymentTypeId, accountNumber, checkNumber, routingCode, receiptNumber, bankNumber
         * @summary Create \"Balanced\" Journal Entries
         * @param {string} [command] command
         * @param {JournalEntryCommand} [journalEntryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGLJournalEntry(command?: string, journalEntryCommand?: JournalEntryCommand, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostJournalEntriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGLJournalEntry(command, journalEntryCommand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API calculates the running balances for office. If office ID not provided this API calculates running balances for all offices.  Mandatory Fields officeId
         * @summary Update Running balances for Journal Entries
         * @param {string} transactionId transactionId
         * @param {string} [command] command
         * @param {PostJournalEntriesTransactionIdRequest} [postJournalEntriesTransactionIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReversalJournalEntry(transactionId: string, command?: string, postJournalEntriesTransactionIdRequest?: PostJournalEntriesTransactionIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostJournalEntriesTransactionIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReversalJournalEntry(transactionId, command, postJournalEntriesTransactionIdRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [officeId] 
         * @param {string} [dateFormat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJournalEntriesTemplate(officeId?: number, dateFormat?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJournalEntriesTemplate(officeId, dateFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {FormDataContentDisposition} [file] 
         * @param {string} [locale] 
         * @param {string} [dateFormat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJournalEntriesTemplate(file?: FormDataContentDisposition, locale?: string, dateFormat?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJournalEntriesTemplate(file, locale, dateFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Example Requests:  journalentries/1    journalentries/1?fields=officeName,glAccountId,entryType,amount  journalentries/1?runningBalance=true  journalentries/1?transactionDetails=true
         * @summary Retrieve a single Entry
         * @param {number} journalEntryId journalEntryId
         * @param {boolean} [runningBalance] runningBalance
         * @param {boolean} [transactionDetails] transactionDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retreiveJournalEntryById(journalEntryId: number, runningBalance?: boolean, transactionDetails?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalEntryData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retreiveJournalEntryById(journalEntryId, runningBalance, transactionDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The list capability of journal entries can support pagination and sorting.  Example Requests:  journalentries  journalentries?transactionId=PB37X8Y21EQUY4S  journalentries?officeId=1&manualEntriesOnly=true&fromDate=1 July 2013&toDate=15 July 2013&dateFormat=dd MMMM yyyy&locale=en  journalentries?fields=officeName,glAccountName,transactionDate  journalentries?offset=10&limit=50  journalentries?orderBy=transactionId&sortOrder=DESC  journalentries?runningBalance=true  journalentries?transactionDetails=true  journalentries?loanId=12  journalentries?savingsId=24
         * @summary List Journal Entries
         * @param {number} [officeId] officeId
         * @param {number} [glAccountId] glAccountId
         * @param {boolean} [manualEntriesOnly] manualEntriesOnly
         * @param {object} [fromDate] fromDate
         * @param {object} [toDate] toDate
         * @param {string} [transactionId] transactionId
         * @param {number} [entityType] entityType
         * @param {number} [offset] offset
         * @param {number} [limit] limit
         * @param {string} [orderBy] orderBy
         * @param {string} [sortOrder] sortOrder
         * @param {string} [locale] locale
         * @param {string} [dateFormat] dateFormat
         * @param {number} [loanId] loanId
         * @param {number} [savingsId] savingsId
         * @param {boolean} [runningBalance] runningBalance
         * @param {boolean} [transactionDetails] transactionDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAll1(officeId?: number, glAccountId?: number, manualEntriesOnly?: boolean, fromDate?: object, toDate?: object, transactionId?: string, entityType?: number, offset?: number, limit?: number, orderBy?: string, sortOrder?: string, locale?: string, dateFormat?: string, loanId?: number, savingsId?: number, runningBalance?: boolean, transactionDetails?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<JournalEntryData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAll1(officeId, glAccountId, manualEntriesOnly, fromDate, toDate, transactionId, entityType, offset, limit, orderBy, sortOrder, locale, dateFormat, loanId, savingsId, runningBalance, transactionDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {number} [entryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveJournalEntries(offset?: number, limit?: number, entryId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveJournalEntries(offset, limit, entryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [officeId] 
         * @param {string} [currencyCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOpeningBalance(officeId?: number, currencyCode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveOpeningBalance(officeId, currencyCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JournalEntriesApi - factory interface
 * @export
 */
export const JournalEntriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JournalEntriesApiFp(configuration)
    return {
        /**
         * Note: A Balanced (simple) Journal entry would have atleast one \"Debit\" and one \"Credit\" entry whose amounts are equal  Compound Journal entries may have \"n\" debits and \"m\" credits where both \"m\" and \"n\" are greater than 0 and the net sum or all debits and credits are equal    Mandatory Fields officeId, transactionDate   credits- glAccountId, amount, comments    debits-  glAccountId, amount, comments    Optional Fields paymentTypeId, accountNumber, checkNumber, routingCode, receiptNumber, bankNumber
         * @summary Create \"Balanced\" Journal Entries
         * @param {string} [command] command
         * @param {JournalEntryCommand} [journalEntryCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGLJournalEntry(command?: string, journalEntryCommand?: JournalEntryCommand, options?: any): AxiosPromise<PostJournalEntriesResponse> {
            return localVarFp.createGLJournalEntry(command, journalEntryCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * This API calculates the running balances for office. If office ID not provided this API calculates running balances for all offices.  Mandatory Fields officeId
         * @summary Update Running balances for Journal Entries
         * @param {string} transactionId transactionId
         * @param {string} [command] command
         * @param {PostJournalEntriesTransactionIdRequest} [postJournalEntriesTransactionIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReversalJournalEntry(transactionId: string, command?: string, postJournalEntriesTransactionIdRequest?: PostJournalEntriesTransactionIdRequest, options?: any): AxiosPromise<PostJournalEntriesTransactionIdResponse> {
            return localVarFp.createReversalJournalEntry(transactionId, command, postJournalEntriesTransactionIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [officeId] 
         * @param {string} [dateFormat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJournalEntriesTemplate(officeId?: number, dateFormat?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getJournalEntriesTemplate(officeId, dateFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FormDataContentDisposition} [file] 
         * @param {string} [locale] 
         * @param {string} [dateFormat] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJournalEntriesTemplate(file?: FormDataContentDisposition, locale?: string, dateFormat?: string, options?: any): AxiosPromise<string> {
            return localVarFp.postJournalEntriesTemplate(file, locale, dateFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * Example Requests:  journalentries/1    journalentries/1?fields=officeName,glAccountId,entryType,amount  journalentries/1?runningBalance=true  journalentries/1?transactionDetails=true
         * @summary Retrieve a single Entry
         * @param {number} journalEntryId journalEntryId
         * @param {boolean} [runningBalance] runningBalance
         * @param {boolean} [transactionDetails] transactionDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retreiveJournalEntryById(journalEntryId: number, runningBalance?: boolean, transactionDetails?: boolean, options?: any): AxiosPromise<JournalEntryData> {
            return localVarFp.retreiveJournalEntryById(journalEntryId, runningBalance, transactionDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * The list capability of journal entries can support pagination and sorting.  Example Requests:  journalentries  journalentries?transactionId=PB37X8Y21EQUY4S  journalentries?officeId=1&manualEntriesOnly=true&fromDate=1 July 2013&toDate=15 July 2013&dateFormat=dd MMMM yyyy&locale=en  journalentries?fields=officeName,glAccountName,transactionDate  journalentries?offset=10&limit=50  journalentries?orderBy=transactionId&sortOrder=DESC  journalentries?runningBalance=true  journalentries?transactionDetails=true  journalentries?loanId=12  journalentries?savingsId=24
         * @summary List Journal Entries
         * @param {number} [officeId] officeId
         * @param {number} [glAccountId] glAccountId
         * @param {boolean} [manualEntriesOnly] manualEntriesOnly
         * @param {object} [fromDate] fromDate
         * @param {object} [toDate] toDate
         * @param {string} [transactionId] transactionId
         * @param {number} [entityType] entityType
         * @param {number} [offset] offset
         * @param {number} [limit] limit
         * @param {string} [orderBy] orderBy
         * @param {string} [sortOrder] sortOrder
         * @param {string} [locale] locale
         * @param {string} [dateFormat] dateFormat
         * @param {number} [loanId] loanId
         * @param {number} [savingsId] savingsId
         * @param {boolean} [runningBalance] runningBalance
         * @param {boolean} [transactionDetails] transactionDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAll1(officeId?: number, glAccountId?: number, manualEntriesOnly?: boolean, fromDate?: object, toDate?: object, transactionId?: string, entityType?: number, offset?: number, limit?: number, orderBy?: string, sortOrder?: string, locale?: string, dateFormat?: string, loanId?: number, savingsId?: number, runningBalance?: boolean, transactionDetails?: boolean, options?: any): AxiosPromise<Array<JournalEntryData>> {
            return localVarFp.retrieveAll1(officeId, glAccountId, manualEntriesOnly, fromDate, toDate, transactionId, entityType, offset, limit, orderBy, sortOrder, locale, dateFormat, loanId, savingsId, runningBalance, transactionDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {number} [entryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveJournalEntries(offset?: number, limit?: number, entryId?: number, options?: any): AxiosPromise<string> {
            return localVarFp.retrieveJournalEntries(offset, limit, entryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [officeId] 
         * @param {string} [currencyCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOpeningBalance(officeId?: number, currencyCode?: string, options?: any): AxiosPromise<string> {
            return localVarFp.retrieveOpeningBalance(officeId, currencyCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JournalEntriesApi - object-oriented interface
 * @export
 * @class JournalEntriesApi
 * @extends {BaseAPI}
 */
export class JournalEntriesApi extends BaseAPI {
    /**
     * Note: A Balanced (simple) Journal entry would have atleast one \"Debit\" and one \"Credit\" entry whose amounts are equal  Compound Journal entries may have \"n\" debits and \"m\" credits where both \"m\" and \"n\" are greater than 0 and the net sum or all debits and credits are equal    Mandatory Fields officeId, transactionDate   credits- glAccountId, amount, comments    debits-  glAccountId, amount, comments    Optional Fields paymentTypeId, accountNumber, checkNumber, routingCode, receiptNumber, bankNumber
     * @summary Create \"Balanced\" Journal Entries
     * @param {string} [command] command
     * @param {JournalEntryCommand} [journalEntryCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JournalEntriesApi
     */
    public createGLJournalEntry(command?: string, journalEntryCommand?: JournalEntryCommand, options?: any) {
        return JournalEntriesApiFp(this.configuration).createGLJournalEntry(command, journalEntryCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API calculates the running balances for office. If office ID not provided this API calculates running balances for all offices.  Mandatory Fields officeId
     * @summary Update Running balances for Journal Entries
     * @param {string} transactionId transactionId
     * @param {string} [command] command
     * @param {PostJournalEntriesTransactionIdRequest} [postJournalEntriesTransactionIdRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JournalEntriesApi
     */
    public createReversalJournalEntry(transactionId: string, command?: string, postJournalEntriesTransactionIdRequest?: PostJournalEntriesTransactionIdRequest, options?: any) {
        return JournalEntriesApiFp(this.configuration).createReversalJournalEntry(transactionId, command, postJournalEntriesTransactionIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [officeId] 
     * @param {string} [dateFormat] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JournalEntriesApi
     */
    public getJournalEntriesTemplate(officeId?: number, dateFormat?: string, options?: any) {
        return JournalEntriesApiFp(this.configuration).getJournalEntriesTemplate(officeId, dateFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FormDataContentDisposition} [file] 
     * @param {string} [locale] 
     * @param {string} [dateFormat] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JournalEntriesApi
     */
    public postJournalEntriesTemplate(file?: FormDataContentDisposition, locale?: string, dateFormat?: string, options?: any) {
        return JournalEntriesApiFp(this.configuration).postJournalEntriesTemplate(file, locale, dateFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Example Requests:  journalentries/1    journalentries/1?fields=officeName,glAccountId,entryType,amount  journalentries/1?runningBalance=true  journalentries/1?transactionDetails=true
     * @summary Retrieve a single Entry
     * @param {number} journalEntryId journalEntryId
     * @param {boolean} [runningBalance] runningBalance
     * @param {boolean} [transactionDetails] transactionDetails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JournalEntriesApi
     */
    public retreiveJournalEntryById(journalEntryId: number, runningBalance?: boolean, transactionDetails?: boolean, options?: any) {
        return JournalEntriesApiFp(this.configuration).retreiveJournalEntryById(journalEntryId, runningBalance, transactionDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The list capability of journal entries can support pagination and sorting.  Example Requests:  journalentries  journalentries?transactionId=PB37X8Y21EQUY4S  journalentries?officeId=1&manualEntriesOnly=true&fromDate=1 July 2013&toDate=15 July 2013&dateFormat=dd MMMM yyyy&locale=en  journalentries?fields=officeName,glAccountName,transactionDate  journalentries?offset=10&limit=50  journalentries?orderBy=transactionId&sortOrder=DESC  journalentries?runningBalance=true  journalentries?transactionDetails=true  journalentries?loanId=12  journalentries?savingsId=24
     * @summary List Journal Entries
     * @param {number} [officeId] officeId
     * @param {number} [glAccountId] glAccountId
     * @param {boolean} [manualEntriesOnly] manualEntriesOnly
     * @param {object} [fromDate] fromDate
     * @param {object} [toDate] toDate
     * @param {string} [transactionId] transactionId
     * @param {number} [entityType] entityType
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [orderBy] orderBy
     * @param {string} [sortOrder] sortOrder
     * @param {string} [locale] locale
     * @param {string} [dateFormat] dateFormat
     * @param {number} [loanId] loanId
     * @param {number} [savingsId] savingsId
     * @param {boolean} [runningBalance] runningBalance
     * @param {boolean} [transactionDetails] transactionDetails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JournalEntriesApi
     */
    public retrieveAll1(officeId?: number, glAccountId?: number, manualEntriesOnly?: boolean, fromDate?: object, toDate?: object, transactionId?: string, entityType?: number, offset?: number, limit?: number, orderBy?: string, sortOrder?: string, locale?: string, dateFormat?: string, loanId?: number, savingsId?: number, runningBalance?: boolean, transactionDetails?: boolean, options?: any) {
        return JournalEntriesApiFp(this.configuration).retrieveAll1(officeId, glAccountId, manualEntriesOnly, fromDate, toDate, transactionId, entityType, offset, limit, orderBy, sortOrder, locale, dateFormat, loanId, savingsId, runningBalance, transactionDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {number} [entryId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JournalEntriesApi
     */
    public retrieveJournalEntries(offset?: number, limit?: number, entryId?: number, options?: any) {
        return JournalEntriesApiFp(this.configuration).retrieveJournalEntries(offset, limit, entryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [officeId] 
     * @param {string} [currencyCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JournalEntriesApi
     */
    public retrieveOpeningBalance(officeId?: number, currencyCode?: string, options?: any) {
        return JournalEntriesApiFp(this.configuration).retrieveOpeningBalance(officeId, currencyCode, options).then((request) => request(this.axios, this.basePath));
    }
}
