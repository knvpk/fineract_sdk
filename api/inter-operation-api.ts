/* tslint:disable */
/* eslint-disable */
/**
 * Apache Fineract
 * Apache Fineract is a secure, multi-tenanted microfinance platform  The goal of the Apache Fineract API is to empower developers to build apps on top of the Apache Fineract Platform<br>The [reference app](https://cui.fineract.dev) (username: mifos, password: password) works on the same demo tenant as the interactive links in this documentation  - The API is organized around [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) - Find out more about Apache Fineract [here](/fineract-provider/api-docs/apiLive.htm#top) - You can [Try The API From Your Browser](/fineract-provider/api-docs/apiLive.htm#interact) - The Generic Options are available [here](/fineract-provider/api-docs/apiLive.htm#genopts) - Find out more about [Updating Dates and Numbers](/fineract-provider/api-docs/apiLive.htm#dates_and_numbers) - For the Authentication and the Basic of HTTP and HTTPS refer [here](/fineract-provider/api-docs/apiLive.htm#authentication_overview) - Check about ERROR codes [here](/fineract-provider/api-docs/apiLive.htm#errors)  Please refer to the [old documentation](/fineract-provider/api-docs/apiLive.htm) for any documentation queries
 *
 * The version of the OpenAPI document: 1.5.0-66-gffae7d4-dirty
 * Contact: dev@fineract.apache.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { InteropAccountData } from '../models';
// @ts-ignore
import { InteropIdentifierAccountResponseData } from '../models';
// @ts-ignore
import { InteropIdentifierRequestData } from '../models';
// @ts-ignore
import { InteropIdentifiersResponseData } from '../models';
// @ts-ignore
import { InteropKycResponseData } from '../models';
// @ts-ignore
import { InteropQuoteRequestData } from '../models';
// @ts-ignore
import { InteropQuoteResponseData } from '../models';
// @ts-ignore
import { InteropTransactionRequestData } from '../models';
// @ts-ignore
import { InteropTransactionRequestResponseData } from '../models';
// @ts-ignore
import { InteropTransactionsData } from '../models';
// @ts-ignore
import { InteropTransferRequestData } from '../models';
// @ts-ignore
import { InteropTransferResponseData } from '../models';
/**
 * InterOperationApi - axios parameter creator
 * @export
 */
export const InterOperationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Calculate Interoperation Quote
         * @param {InteropQuoteRequestData} interopQuoteRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuote: async (interopQuoteRequestData: InteropQuoteRequestData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'interopQuoteRequestData' is not null or undefined
            assertParamExists('createQuote', 'interopQuoteRequestData', interopQuoteRequestData)
            const localVarPath = `/interoperation/quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interopQuoteRequestData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Allow Interoperation Transaction Request
         * @param {InteropTransactionRequestData} interopTransactionRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionRequest: async (interopTransactionRequestData: InteropTransactionRequestData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'interopTransactionRequestData' is not null or undefined
            assertParamExists('createTransactionRequest', 'interopTransactionRequestData', interopTransactionRequestData)
            const localVarPath = `/interoperation/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interopTransactionRequestData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Allow Interoperation Identifier registration
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountIdentifier: async (idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, interopIdentifierRequestData: InteropIdentifierRequestData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'idType' is not null or undefined
            assertParamExists('deleteAccountIdentifier', 'idType', idType)
            // verify required parameter 'idValue' is not null or undefined
            assertParamExists('deleteAccountIdentifier', 'idValue', idValue)
            // verify required parameter 'interopIdentifierRequestData' is not null or undefined
            assertParamExists('deleteAccountIdentifier', 'interopIdentifierRequestData', interopIdentifierRequestData)
            const localVarPath = `/interoperation/parties/{idType}/{idValue}`
                .replace(`{${"idType"}}`, encodeURIComponent(String(idType)))
                .replace(`{${"idValue"}}`, encodeURIComponent(String(idValue)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interopIdentifierRequestData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Allow Interoperation Identifier registration
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {string} subIdOrType subIdOrType
         * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountIdentifier1: async (idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, subIdOrType: string, interopIdentifierRequestData: InteropIdentifierRequestData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'idType' is not null or undefined
            assertParamExists('deleteAccountIdentifier1', 'idType', idType)
            // verify required parameter 'idValue' is not null or undefined
            assertParamExists('deleteAccountIdentifier1', 'idValue', idValue)
            // verify required parameter 'subIdOrType' is not null or undefined
            assertParamExists('deleteAccountIdentifier1', 'subIdOrType', subIdOrType)
            // verify required parameter 'interopIdentifierRequestData' is not null or undefined
            assertParamExists('deleteAccountIdentifier1', 'interopIdentifierRequestData', interopIdentifierRequestData)
            const localVarPath = `/interoperation/parties/{idType}/{idValue}/{subIdOrType}`
                .replace(`{${"idType"}}`, encodeURIComponent(String(idType)))
                .replace(`{${"idValue"}}`, encodeURIComponent(String(idValue)))
                .replace(`{${"subIdOrType"}}`, encodeURIComponent(String(subIdOrType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interopIdentifierRequestData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disburse Loan by Account Id
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disburseLoan: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('disburseLoan', 'accountId', accountId)
            const localVarPath = `/interoperation/transactions/{accountId}/disburse`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query Interoperation Account by secondary identifier
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByIdentifier: async (idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'idType' is not null or undefined
            assertParamExists('getAccountByIdentifier', 'idType', idType)
            // verify required parameter 'idValue' is not null or undefined
            assertParamExists('getAccountByIdentifier', 'idValue', idValue)
            const localVarPath = `/interoperation/parties/{idType}/{idValue}`
                .replace(`{${"idType"}}`, encodeURIComponent(String(idType)))
                .replace(`{${"idValue"}}`, encodeURIComponent(String(idValue)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query Interoperation Account by secondary identifier
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {string} subIdOrType subIdOrType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByIdentifier1: async (idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, subIdOrType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'idType' is not null or undefined
            assertParamExists('getAccountByIdentifier1', 'idType', idType)
            // verify required parameter 'idValue' is not null or undefined
            assertParamExists('getAccountByIdentifier1', 'idValue', idValue)
            // verify required parameter 'subIdOrType' is not null or undefined
            assertParamExists('getAccountByIdentifier1', 'subIdOrType', subIdOrType)
            const localVarPath = `/interoperation/parties/{idType}/{idValue}/{subIdOrType}`
                .replace(`{${"idType"}}`, encodeURIComponent(String(idType)))
                .replace(`{${"idValue"}}`, encodeURIComponent(String(idValue)))
                .replace(`{${"subIdOrType"}}`, encodeURIComponent(String(subIdOrType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query Interoperation Account details
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDetails: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountDetails', 'accountId', accountId)
            const localVarPath = `/interoperation/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query Interoperation secondary identifiers by Account Id
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountIdentifiers: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountIdentifiers', 'accountId', accountId)
            const localVarPath = `/interoperation/accounts/{accountId}/identifiers`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query transactions by Account Id
         * @param {string} accountId accountId
         * @param {boolean} [debit] debit
         * @param {boolean} [credit] credit
         * @param {string} [fromBookingDateTime] fromBookingDateTime
         * @param {string} [toBookingDateTime] toBookingDateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactions: async (accountId: string, debit?: boolean, credit?: boolean, fromBookingDateTime?: string, toBookingDateTime?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountTransactions', 'accountId', accountId)
            const localVarPath = `/interoperation/accounts/{accountId}/transactions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)

            if (debit !== undefined) {
                localVarQueryParameter['debit'] = debit;
            }

            if (credit !== undefined) {
                localVarQueryParameter['credit'] = credit;
            }

            if (fromBookingDateTime !== undefined) {
                localVarQueryParameter['fromBookingDateTime'] = fromBookingDateTime;
            }

            if (toBookingDateTime !== undefined) {
                localVarQueryParameter['toBookingDateTime'] = toBookingDateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query KYC by Account Id
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientKyc: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getClientKyc', 'accountId', accountId)
            const localVarPath = `/interoperation/accounts/{accountId}/kyc`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query Interoperation Quote
         * @param {string} transactionCode transactionCode
         * @param {string} quoteCode quoteCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuote: async (transactionCode: string, quoteCode: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionCode' is not null or undefined
            assertParamExists('getQuote', 'transactionCode', transactionCode)
            // verify required parameter 'quoteCode' is not null or undefined
            assertParamExists('getQuote', 'quoteCode', quoteCode)
            const localVarPath = `/interoperation/transactions/{transactionCode}/quotes/{quoteCode}`
                .replace(`{${"transactionCode"}}`, encodeURIComponent(String(transactionCode)))
                .replace(`{${"quoteCode"}}`, encodeURIComponent(String(quoteCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query Interoperation Transaction Request
         * @param {string} transactionCode transactionCode
         * @param {string} requestCode requestCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRequest: async (transactionCode: string, requestCode: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionCode' is not null or undefined
            assertParamExists('getTransactionRequest', 'transactionCode', transactionCode)
            // verify required parameter 'requestCode' is not null or undefined
            assertParamExists('getTransactionRequest', 'requestCode', requestCode)
            const localVarPath = `/interoperation/transactions/{transactionCode}/requests/{requestCode}`
                .replace(`{${"transactionCode"}}`, encodeURIComponent(String(transactionCode)))
                .replace(`{${"requestCode"}}`, encodeURIComponent(String(requestCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query Interoperation Transfer
         * @param {string} transactionCode transactionCode
         * @param {string} transferCode transferCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (transactionCode: string, transferCode: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionCode' is not null or undefined
            assertParamExists('getTransfer', 'transactionCode', transactionCode)
            // verify required parameter 'transferCode' is not null or undefined
            assertParamExists('getTransfer', 'transferCode', transferCode)
            const localVarPath = `/interoperation/transactions/{transactionCode}/transfers/{transferCode}`
                .replace(`{${"transactionCode"}}`, encodeURIComponent(String(transactionCode)))
                .replace(`{${"transferCode"}}`, encodeURIComponent(String(transferCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query Interoperation Health Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/interoperation/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prepare Interoperation Transfer
         * @param {InteropTransferRequestData} interopTransferRequestData 
         * @param {string} [action] action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performTransfer: async (interopTransferRequestData: InteropTransferRequestData, action?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'interopTransferRequestData' is not null or undefined
            assertParamExists('performTransfer', 'interopTransferRequestData', interopTransferRequestData)
            const localVarPath = `/interoperation/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interopTransferRequestData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Interoperation Identifier registration
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAccountIdentifier: async (idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, interopIdentifierRequestData: InteropIdentifierRequestData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'idType' is not null or undefined
            assertParamExists('registerAccountIdentifier', 'idType', idType)
            // verify required parameter 'idValue' is not null or undefined
            assertParamExists('registerAccountIdentifier', 'idValue', idValue)
            // verify required parameter 'interopIdentifierRequestData' is not null or undefined
            assertParamExists('registerAccountIdentifier', 'interopIdentifierRequestData', interopIdentifierRequestData)
            const localVarPath = `/interoperation/parties/{idType}/{idValue}`
                .replace(`{${"idType"}}`, encodeURIComponent(String(idType)))
                .replace(`{${"idValue"}}`, encodeURIComponent(String(idValue)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interopIdentifierRequestData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Interoperation Identifier registration
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {string} subIdOrType subIdOrType
         * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAccountIdentifier1: async (idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, subIdOrType: string, interopIdentifierRequestData: InteropIdentifierRequestData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'idType' is not null or undefined
            assertParamExists('registerAccountIdentifier1', 'idType', idType)
            // verify required parameter 'idValue' is not null or undefined
            assertParamExists('registerAccountIdentifier1', 'idValue', idValue)
            // verify required parameter 'subIdOrType' is not null or undefined
            assertParamExists('registerAccountIdentifier1', 'subIdOrType', subIdOrType)
            // verify required parameter 'interopIdentifierRequestData' is not null or undefined
            assertParamExists('registerAccountIdentifier1', 'interopIdentifierRequestData', interopIdentifierRequestData)
            const localVarPath = `/interoperation/parties/{idType}/{idValue}/{subIdOrType}`
                .replace(`{${"idType"}}`, encodeURIComponent(String(idType)))
                .replace(`{${"idValue"}}`, encodeURIComponent(String(idValue)))
                .replace(`{${"subIdOrType"}}`, encodeURIComponent(String(subIdOrType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tenantid required
            await setApiKeyToObject(localVarHeaderParameter, "fineract-platform-tenantid", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interopIdentifierRequestData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InterOperationApi - functional programming interface
 * @export
 */
export const InterOperationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InterOperationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Calculate Interoperation Quote
         * @param {InteropQuoteRequestData} interopQuoteRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuote(interopQuoteRequestData: InteropQuoteRequestData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropQuoteResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuote(interopQuoteRequestData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Allow Interoperation Transaction Request
         * @param {InteropTransactionRequestData} interopTransactionRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactionRequest(interopTransactionRequestData: InteropTransactionRequestData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropTransactionRequestResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactionRequest(interopTransactionRequestData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Allow Interoperation Identifier registration
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountIdentifier(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, interopIdentifierRequestData: InteropIdentifierRequestData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropIdentifierAccountResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccountIdentifier(idType, idValue, interopIdentifierRequestData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Allow Interoperation Identifier registration
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {string} subIdOrType subIdOrType
         * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountIdentifier1(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, subIdOrType: string, interopIdentifierRequestData: InteropIdentifierRequestData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropIdentifierAccountResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccountIdentifier1(idType, idValue, subIdOrType, interopIdentifierRequestData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Disburse Loan by Account Id
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disburseLoan(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disburseLoan(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query Interoperation Account by secondary identifier
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByIdentifier(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropIdentifierAccountResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountByIdentifier(idType, idValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query Interoperation Account by secondary identifier
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {string} subIdOrType subIdOrType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByIdentifier1(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, subIdOrType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropIdentifierAccountResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountByIdentifier1(idType, idValue, subIdOrType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query Interoperation Account details
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountDetails(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropAccountData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountDetails(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query Interoperation secondary identifiers by Account Id
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountIdentifiers(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropIdentifiersResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountIdentifiers(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query transactions by Account Id
         * @param {string} accountId accountId
         * @param {boolean} [debit] debit
         * @param {boolean} [credit] credit
         * @param {string} [fromBookingDateTime] fromBookingDateTime
         * @param {string} [toBookingDateTime] toBookingDateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTransactions(accountId: string, debit?: boolean, credit?: boolean, fromBookingDateTime?: string, toBookingDateTime?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropTransactionsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTransactions(accountId, debit, credit, fromBookingDateTime, toBookingDateTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query KYC by Account Id
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientKyc(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropKycResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientKyc(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query Interoperation Quote
         * @param {string} transactionCode transactionCode
         * @param {string} quoteCode quoteCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuote(transactionCode: string, quoteCode: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropQuoteResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuote(transactionCode, quoteCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query Interoperation Transaction Request
         * @param {string} transactionCode transactionCode
         * @param {string} requestCode requestCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionRequest(transactionCode: string, requestCode: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropTransactionRequestResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionRequest(transactionCode, requestCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query Interoperation Transfer
         * @param {string} transactionCode transactionCode
         * @param {string} transferCode transferCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(transactionCode: string, transferCode: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropTransferResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfer(transactionCode, transferCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query Interoperation Health Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prepare Interoperation Transfer
         * @param {InteropTransferRequestData} interopTransferRequestData 
         * @param {string} [action] action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async performTransfer(interopTransferRequestData: InteropTransferRequestData, action?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropTransferResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.performTransfer(interopTransferRequestData, action, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Interoperation Identifier registration
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerAccountIdentifier(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, interopIdentifierRequestData: InteropIdentifierRequestData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropIdentifierAccountResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerAccountIdentifier(idType, idValue, interopIdentifierRequestData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Interoperation Identifier registration
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {string} subIdOrType subIdOrType
         * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerAccountIdentifier1(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, subIdOrType: string, interopIdentifierRequestData: InteropIdentifierRequestData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InteropIdentifierAccountResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerAccountIdentifier1(idType, idValue, subIdOrType, interopIdentifierRequestData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InterOperationApi - factory interface
 * @export
 */
export const InterOperationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InterOperationApiFp(configuration)
    return {
        /**
         * 
         * @summary Calculate Interoperation Quote
         * @param {InteropQuoteRequestData} interopQuoteRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuote(interopQuoteRequestData: InteropQuoteRequestData, options?: any): AxiosPromise<InteropQuoteResponseData> {
            return localVarFp.createQuote(interopQuoteRequestData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Allow Interoperation Transaction Request
         * @param {InteropTransactionRequestData} interopTransactionRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionRequest(interopTransactionRequestData: InteropTransactionRequestData, options?: any): AxiosPromise<InteropTransactionRequestResponseData> {
            return localVarFp.createTransactionRequest(interopTransactionRequestData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Allow Interoperation Identifier registration
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountIdentifier(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, interopIdentifierRequestData: InteropIdentifierRequestData, options?: any): AxiosPromise<InteropIdentifierAccountResponseData> {
            return localVarFp.deleteAccountIdentifier(idType, idValue, interopIdentifierRequestData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Allow Interoperation Identifier registration
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {string} subIdOrType subIdOrType
         * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountIdentifier1(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, subIdOrType: string, interopIdentifierRequestData: InteropIdentifierRequestData, options?: any): AxiosPromise<InteropIdentifierAccountResponseData> {
            return localVarFp.deleteAccountIdentifier1(idType, idValue, subIdOrType, interopIdentifierRequestData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disburse Loan by Account Id
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disburseLoan(accountId: string, options?: any): AxiosPromise<string> {
            return localVarFp.disburseLoan(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query Interoperation Account by secondary identifier
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByIdentifier(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, options?: any): AxiosPromise<InteropIdentifierAccountResponseData> {
            return localVarFp.getAccountByIdentifier(idType, idValue, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query Interoperation Account by secondary identifier
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {string} subIdOrType subIdOrType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByIdentifier1(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, subIdOrType: string, options?: any): AxiosPromise<InteropIdentifierAccountResponseData> {
            return localVarFp.getAccountByIdentifier1(idType, idValue, subIdOrType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query Interoperation Account details
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDetails(accountId: string, options?: any): AxiosPromise<InteropAccountData> {
            return localVarFp.getAccountDetails(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query Interoperation secondary identifiers by Account Id
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountIdentifiers(accountId: string, options?: any): AxiosPromise<InteropIdentifiersResponseData> {
            return localVarFp.getAccountIdentifiers(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query transactions by Account Id
         * @param {string} accountId accountId
         * @param {boolean} [debit] debit
         * @param {boolean} [credit] credit
         * @param {string} [fromBookingDateTime] fromBookingDateTime
         * @param {string} [toBookingDateTime] toBookingDateTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactions(accountId: string, debit?: boolean, credit?: boolean, fromBookingDateTime?: string, toBookingDateTime?: string, options?: any): AxiosPromise<InteropTransactionsData> {
            return localVarFp.getAccountTransactions(accountId, debit, credit, fromBookingDateTime, toBookingDateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query KYC by Account Id
         * @param {string} accountId accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientKyc(accountId: string, options?: any): AxiosPromise<InteropKycResponseData> {
            return localVarFp.getClientKyc(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query Interoperation Quote
         * @param {string} transactionCode transactionCode
         * @param {string} quoteCode quoteCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuote(transactionCode: string, quoteCode: string, options?: any): AxiosPromise<InteropQuoteResponseData> {
            return localVarFp.getQuote(transactionCode, quoteCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query Interoperation Transaction Request
         * @param {string} transactionCode transactionCode
         * @param {string} requestCode requestCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionRequest(transactionCode: string, requestCode: string, options?: any): AxiosPromise<InteropTransactionRequestResponseData> {
            return localVarFp.getTransactionRequest(transactionCode, requestCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query Interoperation Transfer
         * @param {string} transactionCode transactionCode
         * @param {string} transferCode transferCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(transactionCode: string, transferCode: string, options?: any): AxiosPromise<InteropTransferResponseData> {
            return localVarFp.getTransfer(transactionCode, transferCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query Interoperation Health Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: any): AxiosPromise<void> {
            return localVarFp.health(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prepare Interoperation Transfer
         * @param {InteropTransferRequestData} interopTransferRequestData 
         * @param {string} [action] action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performTransfer(interopTransferRequestData: InteropTransferRequestData, action?: string, options?: any): AxiosPromise<InteropTransferResponseData> {
            return localVarFp.performTransfer(interopTransferRequestData, action, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Interoperation Identifier registration
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAccountIdentifier(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, interopIdentifierRequestData: InteropIdentifierRequestData, options?: any): AxiosPromise<InteropIdentifierAccountResponseData> {
            return localVarFp.registerAccountIdentifier(idType, idValue, interopIdentifierRequestData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Interoperation Identifier registration
         * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
         * @param {string} idValue idValue
         * @param {string} subIdOrType subIdOrType
         * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAccountIdentifier1(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, subIdOrType: string, interopIdentifierRequestData: InteropIdentifierRequestData, options?: any): AxiosPromise<InteropIdentifierAccountResponseData> {
            return localVarFp.registerAccountIdentifier1(idType, idValue, subIdOrType, interopIdentifierRequestData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InterOperationApi - object-oriented interface
 * @export
 * @class InterOperationApi
 * @extends {BaseAPI}
 */
export class InterOperationApi extends BaseAPI {
    /**
     * 
     * @summary Calculate Interoperation Quote
     * @param {InteropQuoteRequestData} interopQuoteRequestData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public createQuote(interopQuoteRequestData: InteropQuoteRequestData, options?: any) {
        return InterOperationApiFp(this.configuration).createQuote(interopQuoteRequestData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Allow Interoperation Transaction Request
     * @param {InteropTransactionRequestData} interopTransactionRequestData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public createTransactionRequest(interopTransactionRequestData: InteropTransactionRequestData, options?: any) {
        return InterOperationApiFp(this.configuration).createTransactionRequest(interopTransactionRequestData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Allow Interoperation Identifier registration
     * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
     * @param {string} idValue idValue
     * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public deleteAccountIdentifier(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, interopIdentifierRequestData: InteropIdentifierRequestData, options?: any) {
        return InterOperationApiFp(this.configuration).deleteAccountIdentifier(idType, idValue, interopIdentifierRequestData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Allow Interoperation Identifier registration
     * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
     * @param {string} idValue idValue
     * @param {string} subIdOrType subIdOrType
     * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public deleteAccountIdentifier1(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, subIdOrType: string, interopIdentifierRequestData: InteropIdentifierRequestData, options?: any) {
        return InterOperationApiFp(this.configuration).deleteAccountIdentifier1(idType, idValue, subIdOrType, interopIdentifierRequestData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disburse Loan by Account Id
     * @param {string} accountId accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public disburseLoan(accountId: string, options?: any) {
        return InterOperationApiFp(this.configuration).disburseLoan(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query Interoperation Account by secondary identifier
     * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
     * @param {string} idValue idValue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public getAccountByIdentifier(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, options?: any) {
        return InterOperationApiFp(this.configuration).getAccountByIdentifier(idType, idValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query Interoperation Account by secondary identifier
     * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
     * @param {string} idValue idValue
     * @param {string} subIdOrType subIdOrType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public getAccountByIdentifier1(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, subIdOrType: string, options?: any) {
        return InterOperationApiFp(this.configuration).getAccountByIdentifier1(idType, idValue, subIdOrType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query Interoperation Account details
     * @param {string} accountId accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public getAccountDetails(accountId: string, options?: any) {
        return InterOperationApiFp(this.configuration).getAccountDetails(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query Interoperation secondary identifiers by Account Id
     * @param {string} accountId accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public getAccountIdentifiers(accountId: string, options?: any) {
        return InterOperationApiFp(this.configuration).getAccountIdentifiers(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query transactions by Account Id
     * @param {string} accountId accountId
     * @param {boolean} [debit] debit
     * @param {boolean} [credit] credit
     * @param {string} [fromBookingDateTime] fromBookingDateTime
     * @param {string} [toBookingDateTime] toBookingDateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public getAccountTransactions(accountId: string, debit?: boolean, credit?: boolean, fromBookingDateTime?: string, toBookingDateTime?: string, options?: any) {
        return InterOperationApiFp(this.configuration).getAccountTransactions(accountId, debit, credit, fromBookingDateTime, toBookingDateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query KYC by Account Id
     * @param {string} accountId accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public getClientKyc(accountId: string, options?: any) {
        return InterOperationApiFp(this.configuration).getClientKyc(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query Interoperation Quote
     * @param {string} transactionCode transactionCode
     * @param {string} quoteCode quoteCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public getQuote(transactionCode: string, quoteCode: string, options?: any) {
        return InterOperationApiFp(this.configuration).getQuote(transactionCode, quoteCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query Interoperation Transaction Request
     * @param {string} transactionCode transactionCode
     * @param {string} requestCode requestCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public getTransactionRequest(transactionCode: string, requestCode: string, options?: any) {
        return InterOperationApiFp(this.configuration).getTransactionRequest(transactionCode, requestCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query Interoperation Transfer
     * @param {string} transactionCode transactionCode
     * @param {string} transferCode transferCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public getTransfer(transactionCode: string, transferCode: string, options?: any) {
        return InterOperationApiFp(this.configuration).getTransfer(transactionCode, transferCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query Interoperation Health Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public health(options?: any) {
        return InterOperationApiFp(this.configuration).health(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prepare Interoperation Transfer
     * @param {InteropTransferRequestData} interopTransferRequestData 
     * @param {string} [action] action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public performTransfer(interopTransferRequestData: InteropTransferRequestData, action?: string, options?: any) {
        return InterOperationApiFp(this.configuration).performTransfer(interopTransferRequestData, action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Interoperation Identifier registration
     * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
     * @param {string} idValue idValue
     * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public registerAccountIdentifier(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, interopIdentifierRequestData: InteropIdentifierRequestData, options?: any) {
        return InterOperationApiFp(this.configuration).registerAccountIdentifier(idType, idValue, interopIdentifierRequestData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Interoperation Identifier registration
     * @param {'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS'} idType idType
     * @param {string} idValue idValue
     * @param {string} subIdOrType subIdOrType
     * @param {InteropIdentifierRequestData} interopIdentifierRequestData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterOperationApi
     */
    public registerAccountIdentifier1(idType: 'MSISDN' | 'EMAIL' | 'PERSONAL_ID' | 'BUSINESS' | 'DEVICE' | 'ACCOUNT_ID' | 'IBAN' | 'ALIAS', idValue: string, subIdOrType: string, interopIdentifierRequestData: InteropIdentifierRequestData, options?: any) {
        return InterOperationApiFp(this.configuration).registerAccountIdentifier1(idType, idValue, subIdOrType, interopIdentifierRequestData, options).then((request) => request(this.axios, this.basePath));
    }
}
